# -*- coding: utf-8 -*-
"""
Created on Sun Jun  8 10:41:05 2025

@author: kalya
"""

import os
import requests
import json
import re
from bs4 import BeautifulSoup
from dotenv import load_dotenv
import streamlit as st
# Load environment variables from .env file
load_dotenv()

def call_ollama(prompt):
    prompt = prompt + ''' Output only the full working HTML document including embedded CSS and JavaScript 
    — no explanations, no markdown, just the code. It should be a single-page website with a hero banner, 
    about section, gallery section, and contact form. In about section write 10 lines according to topic
    of prompt. Our Gallery section upto 6 photos.Our phograpgaer section upto 6 photos with photograpger name. Add copyright of year © 2025. '''
                
    response = requests.post(
        'http://localhost:11434/api/generate',
        json={
            "model": "qwen2.5:1.5b",
            "prompt": prompt,
            "stream": False
        }
    )
    return response.json()["response"]
#--------------------START: Post process html--------------------------------

# def post_process_html(ollama_html_content: str) -> str:
#     """
#     Post-processes raw HTML content generated by OLLAMA Deepseek to apply modern styling
#     using Tailwind CSS and Google Fonts.

#     Args:
#         ollama_html_content (str): The raw HTML string output from OLLAMA Deepseek.

#     Returns:
#         str: The styled HTML content with Tailwind CSS and Google Fonts applied.
#     """
#     # 1. Parse the HTML content using BeautifulSoup
#     soup = BeautifulSoup(ollama_html_content, 'html.parser')

#     # Find the head and body tags
#     head = soup.find('head')
#     body = soup.find('body')

#     # If head or body not found, return original content as we can't process it meaningfully
#     if not head or not body:
#         print("Warning: HTML structure missing <head> or <body> tags. Cannot post-process.")
#         return ollama_html_content

#     # 2. Inject Tailwind CDN Script
#     # Create a new script tag for Tailwind CSS
#     tailwind_script = soup.new_tag("script", src="https://cdn.tailwindcss.com")
#     head.append(tailwind_script)
#     # Add a newline for better readability in the output HTML
#     head.append(soup.new_string("\n"))

#     # 3. Inject Google Fonts Link (Inter)
#     # Create a new link tag for the Inter font
#     inter_font_link = soup.new_tag("link", rel="stylesheet",
#                                     href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap")
#     head.append(inter_font_link)
#     head.append(soup.new_string("\n"))

#     # 4. Apply Base Body Styles
#     # Add Tailwind classes to the body tag for default font, background, padding, etc.
#     body['class'] = body.get('class', []) + ['font-["Inter"]', 'bg-gray-100', 'p-8', 'antialiased', 'text-gray-800']

#     # 5. Apply Tailwind Classes to Common HTML Elements based on the example structure

#     # Main content container (assuming a single main div)
#     # This targets the first div directly under the body, often used as a main container
#     main_container = body.find('div')
#     if main_container:
#         main_container['class'] = main_container.get('class', []) + ['max-w-4xl', 'mx-auto', 'bg-white', 'rounded-xl', 'shadow-lg', 'p-6', 'md:p-10']

#     # Header section
#     header = body.find('header')
#     if header:
#         header['class'] = header.get('class', []) + ['text-center', 'mb-10']
#         # Apply styles to h1 within header
#         h1 = header.find('h1')
#         if h1:
#             h1['class'] = h1.get('class', []) + ['text-4xl', 'md:text-5xl', 'font-extrabold', 'text-blue-700', 'mb-4']
#         # Apply styles to p within header
#         p_header = header.find('p')
#         if p_header:
#             p_header['class'] = p_header.get('class', []) + ['text-lg', 'md:text-xl', 'text-gray-600']

#     # Feature sections (assuming sections containing divs as cards)
#     feature_sections = body.find_all('section')
#     for section in feature_sections:
#         # Check if this section contains divs that look like feature cards
#         if section.find('div') and not section.find('button'): # Simple heuristic to distinguish from CTA section
#             section['class'] = section.get('class', []) + ['grid', 'grid-cols-1', 'md:grid-cols-2', 'lg:grid-cols-3', 'gap-6', 'mb-10']
#             # Apply styles to divs (cards) within this section
#             cards = section.find_all('div')
#             for card in cards:
#                 # Add base card styles, assuming these are the actual cards
#                 card['class'] = card.get('class', []) + ['bg-white', 'p-6', 'rounded-lg', 'shadow-md', 'hover:shadow-xl', 'transition-shadow', 'duration-300']
#                 # Apply different background colors for variety, based on order
#                 if 'blue-50' not in ' '.join(card.get('class', [])) and \
#                    'green-50' not in ' '.join(card.get('class', [])) and \
#                    'yellow-50' not in ' '.join(card.get('class', [])):
#                     if card == cards[0]:
#                         card['class'].append('bg-blue-50')
#                     elif card == cards[1]:
#                         card['class'].append('bg-green-50')
#                     elif card == cards[2]:
#                         card['class'].append('bg-yellow-50')

#                 # Apply styles to h2 within cards
#                 h2_card = card.find('h2')
#                 if h2_card:
#                     h2_card['class'] = h2_card.get('class', []) + ['text-2xl', 'font-semibold', 'mb-3']
#                     if 'blue-600' not in ' '.join(h2_card.get('class', [])) and \
#                        'green-600' not in ' '.join(h2_card.get('class', [])) and \
#                        'yellow-600' not in ' '.join(h2_card.get('class', [])):
#                         if card == cards[0]:
#                             h2_card['class'].append('text-blue-600')
#                         elif card == cards[1]:
#                             h2_card['class'].append('text-green-600')
#                         elif card == cards[2]:
#                             h2_card['class'].append('text-yellow-600')

#                 # Apply styles to p within cards
#                 p_card = card.find('p')
#                 if p_card:
#                     p_card['class'] = p_card.get('class', []) + ['text-gray-700']


#     # Call to Action section (assuming a section with an h2 and a button)
#     # Find section that contains a button and an h2, and isn't the footer
#     cta_section = None
#     for section in body.find_all('section'):
#         if section.find('button') and section.find('h2'):
#             cta_section = section
#             break

#     if cta_section:
#         cta_section['class'] = cta_section.get('class', []) + ['text-center', 'mb-10']
#         h2_cta = cta_section.find('h2')
#         if h2_cta:
#             h2_cta['class'] = h2_cta.get('class', []) + ['text-3xl', 'font-bold', 'mb-6', 'text-gray-800']
#         button = cta_section.find('button')
#         if button:
#             button['class'] = button.get('class', []) + ['bg-blue-600', 'hover:bg-blue-700', 'text-white',
#                                                        'font-bold', 'py-3', 'px-8', 'rounded-full', 'shadow-lg',
#                                                        'hover:shadow-xl', 'transition-all', 'duration-300', 'text-lg']

#     # Footer section
#     footer = body.find('footer')
#     if footer:
#         footer['class'] = footer.get('class', []) + ['text-center', 'text-gray-500', 'text-sm', 'pt-8', 'border-t', 'border-gray-200']

#     # Return the modified HTML as a string
#     return str(soup)

# def post_process_html(ollama_html_content: str) -> str:
#     """
#     Post-processes raw HTML content generated by OLLAMA Deepseek to apply consistent modern styling
#     (card-like appearance) using Tailwind CSS and Google Fonts to all major content sections.

#     Args:
#         ollama_html_content (str): The raw HTML string output from OLLAMA Deepseek.

#     Returns:
#         str: The styled HTML content with Tailwind CSS and Google Fonts applied.
#     """
#     soup = BeautifulSoup(ollama_html_content, 'html.parser')

#     head = soup.find('head')
#     body = soup.find('body')

#     if not head or not body:
#         print("Warning: HTML structure missing <head> or <body> tags. Cannot post-process.")
#         return ollama_html_content

#     # 1. Inject Tailwind CDN Script (ensure it's only added once)
#     if not soup.find('script', src="https://cdn.tailwindcss.com"):
#         tailwind_script = soup.new_tag("script", src="https://cdn.tailwindcss.com")
#         head.append(tailwind_script)
#         head.append(soup.new_string("\n")) # Add a newline for readability

#     # 2. Inject Google Fonts Link (Inter) (ensure it's only added once)
#     if not soup.find('link', href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"):
#         inter_font_link = soup.new_tag("link", rel="stylesheet",
#                                         href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap")
#         head.append(inter_font_link)
#         head.append(soup.new_string("\n"))

#     # 3. Apply Base Body Styles
#     body_classes = body.get('class', [])
#     body_classes.extend(['font-["Inter"]', 'bg-gray-100', 'p-4', 'sm:p-8', 'antialiased', 'text-gray-800', 'min-h-screen', 'flex', 'flex-col', 'items-center', 'justify-center'])
#     body['class'] = body_classes

#     # Ensure the viewport meta tag is present and correct
#     if not soup.find('meta', {'name': 'viewport'}):
#         viewport_meta = soup.new_tag("meta", name="viewport", content="width=device-width, initial-scale=1.0")
#         head.append(viewport_meta)
#         head.append(soup.new_string("\n"))

#     # Find or create a main wrapper div for consistent maximum width and centering
#     main_wrapper = soup.find('div', class_='main-content-wrapper')
#     if not main_wrapper:
#         main_wrapper = soup.new_tag('div', class_='main-content-wrapper')
#         # Move all original direct children of body into this new wrapper
#         for child in list(body.contents): # Use list() to avoid issues with modification during iteration
#             main_wrapper.append(child)
#         body.append(main_wrapper)
#     main_wrapper_classes = main_wrapper.get('class', [])
#     main_wrapper_classes.extend(['w-full', 'max-w-4xl', 'space-y-6', 'py-6']) # Added space-y for vertical spacing between sections
#     main_wrapper['class'] = main_wrapper_classes

#     # 4. Apply Consistent Card/Section Styling to all <section> elements and main divs
#     # This loop applies consistent styling to all <section> tags
#     sections_and_main_divs = soup.find_all(['section']) + soup.find_all('div', recursive=False) # Get top-level divs too
#     applied_sections = set() # To avoid double-applying to the main wrapper or already styled elements

#     for elem in sections_and_main_divs:
#         # Skip if already identified as the main wrapper, or if it's the <body>, <head>, or a script/link tag
#         if 'main-content-wrapper' in elem.get('class', []) or elem.name in ['head', 'body', 'script', 'link', 'meta', 'style']:
#             continue

#         # Check if the element contains content and is a significant block, not just an empty div or very small
#         if not elem.get_text(strip=True) and not elem.find_all(lambda tag: tag.name not in ['script', 'style', 'meta', 'link']):
#             continue # Skip if it's an effectively empty block

#         # Apply card-like styling if not already present, ensuring it's a distinct content block
#         current_classes = elem.get('class', [])
#         # Heuristic: Don't reapply if it already has explicit styling that suggests it's designed
#         if not any(c.startswith(('bg-', 'p-', 'rounded-', 'shadow-')) for c in current_classes):
#             elem_classes = current_classes + ['bg-white', 'p-6', 'rounded-xl', 'shadow-lg']
#             elem['class'] = elem_classes
#             applied_sections.add(elem)

#         # Ensure headings within these sections are styled
#         for h_tag in elem.find_all(['h1', 'h2', 'h3', 'h4', 'h5', 'h6']):
#             h_classes = h_tag.get('class', [])
#             if h_tag.name == 'h1':
#                 h_classes.extend(['text-3xl', 'md:text-4xl', 'font-bold', 'mb-4', 'text-gray-800'])
#             elif h_tag.name == 'h2':
#                 h_classes.extend(['text-2xl', 'md:text-3xl', 'font-semibold', 'mb-3', 'text-gray-700'])
#             elif h_tag.name == 'h3':
#                 h_classes.extend(['text-xl', 'md:text-2xl', 'font-semibold', 'mb-2', 'text-gray-700'])
#             h_tag['class'] = h_classes

#         # Ensure paragraphs within these sections are styled
#         for p_tag in elem.find_all('p'):
#             p_classes = p_tag.get('class', [])
#             p_classes.extend(['text-gray-700', 'mb-4']) # Add margin bottom for paragraphs
#             p_tag['class'] = p_classes

#         # Ensure images are responsive
#         for img_tag in elem.find_all('img'):
#             img_classes = img_tag.get('class', [])
#             img_classes.extend(['w-full', 'h-auto', 'rounded-lg', 'object-cover', 'mt-4', 'mb-4'])
#             img_tag['class'] = img_classes


#     # Specific styling for the header (if not already handled by a section)
#     header = soup.find('header')
#     if header and header not in applied_sections:
#         header_classes = header.get('class', [])
#         header_classes.extend(['text-center', 'mb-10', 'py-4'])
#         header['class'] = header_classes
#         h1 = header.find('h1')
#         if h1:
#             h1_classes = h1.get('class', [])
#             h1_classes.extend(['text-4xl', 'md:text-5xl', 'font-extrabold', 'text-blue-700', 'mb-4'])
#             h1['class'] = h1_classes
#         p_header = header.find('p')
#         if p_header:
#             p_classes = p_header.get('class', [])
#             p_classes.extend(['text-lg', 'md:text-xl', 'text-gray-600'])
#             p_header['class'] = p_classes

#     # Specific styling for buttons
#     for button_tag in soup.find_all('button'):
#         button_classes = button_tag.get('class', [])
#         # Add common button styles if not already present
#         if not any(c.startswith('bg-') for c in button_classes):
#              button_classes.extend(['bg-blue-600', 'hover:bg-blue-700', 'text-white', 'font-bold',
#                                     'py-3', 'px-6', 'rounded-lg', 'shadow-md', 'hover:shadow-lg',
#                                     'transition-all', 'duration-300', 'text-lg', 'inline-flex', 'items-center', 'justify-center'])
#         button_tag['class'] = button_classes

#     # Specific styling for links that look like buttons
#     for a_tag in soup.find_all('a'):
#         # If an anchor tag contains text like "Learn More" or "View Details" and is not inside a nav
#         if a_tag.get_text(strip=True).lower() in ["learn more", "view details", "read more", "get started"] and not a_tag.find_parent('nav'):
#             a_classes = a_tag.get('class', [])
#             if not any(c.startswith('bg-') for c in a_classes):
#                 a_classes.extend(['bg-blue-600', 'hover:bg-blue-700', 'text-white', 'font-bold',
#                                   'py-2', 'px-4', 'rounded-lg', 'shadow-md', 'hover:shadow-lg',
#                                   'transition-all', 'duration-300', 'inline-block', 'mt-4'])
#             a_tag['class'] = a_classes
#         else: # Default link styling
#             a_classes = a_tag.get('class', [])
#             if not any(c.startswith('text-') for c in a_classes):
#                 a_classes.extend(['text-blue-600', 'hover:underline'])
#             a_tag['class'] = a_classes


#     # Specific styling for the footer
#     footer = soup.find('footer')
#     if footer:
#         footer_classes = footer.get('class', [])
#         footer_classes.extend(['text-center', 'text-gray-500', 'text-sm', 'pt-8', 'border-t', 'border-gray-200', 'mt-10']) # Added margin-top
#         footer['class'] = footer_classes

#     # Return the modified HTML as a string
#     return str(soup)
# def post_process_html(ollama_html_content: str) -> str:
#     """
#     Post-processes raw HTML content generated by OLLAMA Deepseek to apply consistent modern styling
#     (card-like appearance) using Tailwind CSS and Google Fonts to all major content sections.

#     Args:
#         ollama_html_content (str): The raw HTML string output from OLLAMA Deepseek.

#     Returns:
#         str: The styled HTML content with Tailwind CSS and Google Fonts applied.
#     """
#     soup = BeautifulSoup(ollama_html_content, 'html.parser')

#     head = soup.find('head')
#     body = soup.find('body')

#     if not head or not body:
#         print("Warning: HTML structure missing <head> or <body> tags. Cannot post-process.")
#         return ollama_html_content

#     # 1. Inject Tailwind CDN Script (ensure it's only added once)
#     if not soup.find('script', src="https://cdn.tailwindcss.com"):
#         tailwind_script = soup.new_tag("script", src="https://cdn.tailwindcss.com")
#         head.append(tailwind_script)
#         head.append(soup.new_string("\n")) # Add a newline for readability

#     # 2. Inject Google Fonts Link (Inter) (ensure it's only added once)
#     if not soup.find('link', href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"):
#         inter_font_link = soup.new_tag("link", rel="stylesheet",
#                                         href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap")
#         head.append(inter_font_link)
#         head.append(soup.new_string("\n"))

#     # 3. Apply Base Body Styles
#     body_classes = body.get('class', [])
#     body_classes.extend(['font-["Inter"]', 'bg-gray-100', 'p-4', 'sm:p-8', 'antialiased', 'text-gray-800', 'min-h-screen', 'flex', 'flex-col', 'items-center', 'justify-center'])
#     body['class'] = body_classes

#     # Ensure the viewport meta tag is present and correct
#     if not soup.find('meta', {'name': 'viewport'}):
#         viewport_meta = soup.new_tag("meta", name="viewport", content="width=device-width, initial-scale=1.0")
#         head.append(viewport_meta)
#         head.append(soup.new_string("\n"))

#     # Find or create a main wrapper div for consistent maximum width and centering
#     main_wrapper = soup.find('div', class_='main-content-wrapper')
#     if not main_wrapper:
#         main_wrapper = soup.new_tag('div', class_='main-content-wrapper')
#         # Move all original direct children of body into this new wrapper
#         for child in list(body.contents): # Use list() to avoid issues with modification during iteration
#             main_wrapper.append(child)
#         body.append(main_wrapper)
#     main_wrapper_classes = main_wrapper.get('class', [])
#     main_wrapper_classes.extend(['w-full', 'max-w-4xl', 'space-y-6', 'py-6']) # Added space-y for vertical spacing between sections
#     main_wrapper['class'] = main_wrapper_classes

#     # 4. Apply Consistent Card/Section Styling to all <section> elements and main divs
#     # This loop applies consistent styling to all <section> tags
#     sections_and_main_divs = soup.find_all(['section']) + soup.find_all('div', recursive=False) # Get top-level divs too
#     applied_sections = set() # To avoid double-applying to the main wrapper or already styled elements

#     for elem in sections_and_main_divs:
#         # Skip if already identified as the main wrapper, or if it's the <body>, <head>, or a script/link tag
#         if 'main-content-wrapper' in elem.get('class', []) or elem.name in ['head', 'body', 'script', 'link', 'meta', 'style']:
#             continue

#         # Check if the element contains content and is a significant block, not just an empty div or very small
#         if not elem.get_text(strip=True) and not elem.find_all(lambda tag: tag.name not in ['script', 'style', 'meta', 'link']):
#             continue # Skip if it's an effectively empty block

#         # Apply card-like styling if not already present, ensuring it's a distinct content block
#         current_classes = elem.get('class', [])
#         # Heuristic: Don't reapply if it already has explicit styling that suggests it's designed
#         if not any(c.startswith(('bg-', 'p-', 'rounded-', 'shadow-')) for c in current_classes):
#             elem_classes = current_classes + ['bg-white', 'p-6', 'rounded-xl', 'shadow-lg']
#             elem['class'] = elem_classes
#             applied_sections.add(elem)

#         # Ensure headings within these sections are styled
#         for h_tag in elem.find_all(['h1', 'h2', 'h3', 'h4', 'h5', 'h6']):
#             h_classes = h_tag.get('class', [])
#             if h_tag.name == 'h1':
#                 h_classes.extend(['text-3xl', 'md:text-4xl', 'font-bold', 'mb-4', 'text-gray-800'])
#             elif h_tag.name == 'h2':
#                 h_classes.extend(['text-2xl', 'md:text-3xl', 'font-semibold', 'mb-3', 'text-gray-700'])
#             elif h_tag.name == 'h3':
#                 h_classes.extend(['text-xl', 'md:text-2xl', 'font-semibold', 'mb-2', 'text-gray-700'])
#             h_tag['class'] = h_classes

#         # Ensure paragraphs within these sections are styled
#         for p_tag in elem.find_all('p'):
#             p_classes = p_tag.get('class', [])
#             p_classes.extend(['text-gray-700', 'mb-4']) # Add margin bottom for paragraphs
#             p_tag['class'] = p_classes

#         # Ensure images are responsive
#         for img_tag in elem.find_all('img'):
#             img_classes = img_tag.get('class', [])
#             img_classes.extend(['w-full', 'h-auto', 'rounded-lg', 'object-cover', 'mt-4', 'mb-4'])
#             img_tag['class'] = img_classes


#     # Specific styling for the header (if not already handled by a section)
#     header = soup.find('header')
#     if header and header not in applied_sections:
#         header_classes = header.get('class', [])
#         header_classes.extend(['text-center', 'mb-10', 'py-4'])
#         header['class'] = header_classes
#         h1 = header.find('h1')
#         if h1:
#             h1_classes = h1.get('class', [])
#             h1_classes.extend(['text-4xl', 'md:text-5xl', 'font-extrabold', 'text-blue-700', 'mb-4'])
#             h1['class'] = h1_classes
#         p_header = header.find('p')
#         if p_header:
#             p_classes = p_header.get('class', [])
#             p_classes.extend(['text-lg', 'md:text-xl', 'text-gray-600'])
#             p_header['class'] = p_classes

#     # Specific styling for buttons
#     for button_tag in soup.find_all('button'):
#         button_classes = button_tag.get('class', [])
#         # Add common button styles if not already present
#         if not any(c.startswith('bg-') for c in button_classes):
#              button_classes.extend(['bg-blue-600', 'hover:bg-blue-700', 'text-white', 'font-bold',
#                                     'py-3', 'px-6', 'rounded-lg', 'shadow-md', 'hover:shadow-lg',
#                                     'transition-all', 'duration-300', 'text-lg', 'inline-flex', 'items-center', 'justify-center'])
#         button_tag['class'] = button_classes

#     # Specific styling for links that look like buttons
#     for a_tag in soup.find_all('a'):
#         # If an anchor tag contains text like "Learn More" or "View Details" and is not inside a nav
#         if a_tag.get_text(strip=True).lower() in ["learn more", "view details", "read more", "get started"] and not a_tag.find_parent('nav'):
#             a_classes = a_tag.get('class', [])
#             if not any(c.startswith('bg-') for c in a_classes):
#                 a_classes.extend(['bg-blue-600', 'hover:bg-blue-700', 'text-white', 'font-bold',
#                                   'py-2', 'px-4', 'rounded-lg', 'shadow-md', 'hover:shadow-lg',
#                                   'transition-all', 'duration-300', 'inline-block', 'mt-4'])
#             a_tag['class'] = a_classes
#         else: # Default link styling
#             a_classes = a_tag.get('class', [])
#             if not any(c.startswith('text-') for c in a_classes):
#                 a_classes.extend(['text-blue-600', 'hover:underline'])
#             a_tag['class'] = a_classes


#     # Specific styling for the footer
#     footer = soup.find('footer')
#     if footer:
#         footer_classes = footer.get('class', [])
#         footer_classes.extend(['text-center', 'text-gray-500', 'text-sm', 'pt-8', 'border-t', 'border-gray-200', 'mt-10']) # Added margin-top
#         footer['class'] = footer_classes

#     # Return the modified HTML as a string
#     return str(soup)
def post_process_html(ollama_html_content: str) -> str:
    """
    Post-processes raw HTML content generated by OLLAMA Deepseek to apply consistent modern styling
    (card-like appearance) using Tailwind CSS and Google Fonts to all major content sections,
    and special styling for large hero/banner images.

    Args:
        ollama_html_content (str): The raw HTML string output from OLLAMA Deepseek.

    Returns:
        str: The styled HTML content with Tailwind CSS and Google Fonts applied.
    """
    soup = BeautifulSoup(ollama_html_content, 'html.parser')

    head = soup.find('head')
    body = soup.find('body')

    if not head or not body:
        print("Warning: HTML structure missing <head> or <body> tags. Cannot post-process.")
        return ollama_html_content

    # 1. Inject Tailwind CDN Script (ensure it's only added once)
    if not soup.find('script', src="https://cdn.tailwindcss.com"):
        tailwind_script = soup.new_tag("script", src="https://cdn.tailwindcss.com")
        head.append(tailwind_script)
        head.append(soup.new_string("\n")) # Add a newline for readability

    # 2. Inject Google Fonts Link (Inter) (ensure it's only added once)
    if not soup.find('link', href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"):
        inter_font_link = soup.new_tag("link", rel="stylesheet",
                                        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap")
        head.append(inter_font_link)
        head.append(soup.new_string("\n"))

    # 3. Apply Base Body Styles
    body_classes = body.get('class', [])
    body_classes.extend(['font-["Inter"]', 'bg-gray-100', 'p-4', 'sm:p-8', 'antialiased', 'text-gray-800', 'min-h-screen', 'flex', 'flex-col', 'items-center', 'justify-center'])
    body['class'] = body_classes

    # Ensure the viewport meta tag is present and correct
    if not soup.find('meta', {'name': 'viewport'}):
        viewport_meta = soup.new_tag("meta", name="viewport", content="width=device-width, initial-scale=1.0")
        head.append(viewport_meta)
        head.append(soup.new_string("\n"))

    # Find or create a main wrapper div for consistent maximum width and centering
    # This wrapper will contain all content *except* for full-width hero elements
    main_wrapper = soup.find('div', class_='main-content-wrapper')
    if not main_wrapper:
        main_wrapper = soup.new_tag('div', class_='main-content-wrapper')
        # Temporarily store children to re-parent them, handling potential hero image placement
        children_to_reparent = []
        for child in list(body.contents):
            # Check if this child is a standalone image (potential hero) or a header containing an image
            is_potential_hero_container = False
            if child.name == 'img':
                is_potential_hero_container = True
            elif child.name == 'header' and child.find('img'):
                is_potential_hero_container = True

            if is_potential_hero_container:
                # If it's a potential hero, we might treat it separately from the main wrapper
                # For now, append it directly to body's children that will be processed later
                children_to_reparent.append(child)
            else:
                # Other content goes into the main wrapper
                main_wrapper.append(child)
        body.clear() # Clear body contents
        # Re-add potential hero containers first, then the main wrapper
        for child in children_to_reparent:
            body.append(child)
        if main_wrapper.contents: # Only append if it has content
            body.append(main_wrapper)
    
    main_wrapper_classes = main_wrapper.get('class', [])
    main_wrapper_classes.extend(['w-full', 'max-w-4xl', 'space-y-6', 'py-6']) # Added space-y for vertical spacing between sections
    main_wrapper['class'] = main_wrapper_classes


    # 4. Apply Consistent Card/Section Styling to all <section> elements and major content divs
    # This loop applies consistent styling to all <section> tags and significant top-level divs within the main_wrapper
    sections_and_main_divs_in_wrapper = main_wrapper.find_all(['section']) + main_wrapper.find_all('div', recursive=False)
    
    applied_sections = set() # To avoid double-applying to the main wrapper or already styled elements

    for elem in sections_and_main_divs_in_wrapper:
        # Skip if already identified as the main wrapper, or if it's the <body>, <head>, or a script/link tag
        if 'main-content-wrapper' in elem.get('class', []) or elem.name in ['head', 'body', 'script', 'link', 'meta', 'style']:
            continue

        # Check if the element contains content and is a significant block, not just an empty div or very small
        if not elem.get_text(strip=True) and not elem.find_all(lambda tag: tag.name not in ['script', 'style', 'meta', 'link']):
            continue # Skip if it's an effectively empty block

        # Apply card-like styling if not already present, ensuring it's a distinct content block
        current_classes = elem.get('class', [])
        # Heuristic: Don't reapply if it already has explicit styling that suggests it's designed
        if not any(c.startswith(('bg-', 'p-', 'rounded-', 'shadow-')) for c in current_classes):
            elem_classes = current_classes + ['bg-white', 'p-6', 'rounded-xl', 'shadow-lg']
            elem['class'] = elem_classes
            applied_sections.add(elem)

        # Ensure headings within these sections are styled
        for h_tag in elem.find_all(['h1', 'h2', 'h3', 'h4', 'h5', 'h6']):
            h_classes = h_tag.get('class', [])
            if h_tag.name == 'h1':
                h_classes.extend(['text-3xl', 'md:text-4xl', 'font-bold', 'mb-4', 'text-gray-800'])
            elif h_tag.name == 'h2':
                h_classes.extend(['text-2xl', 'md:text-3xl', 'font-semibold', 'mb-3', 'text-gray-700'])
            elif h_tag.name == 'h3':
                h_classes.extend(['text-xl', 'md:text-2xl', 'font-semibold', 'mb-2', 'text-gray-700'])
            h_tag['class'] = h_classes

        # Ensure paragraphs within these sections are styled
        for p_tag in elem.find_all('p'):
            p_classes = p_tag.get('class', [])
            p_classes.extend(['text-gray-700', 'mb-4']) # Add margin bottom for paragraphs
            p_tag['class'] = p_classes


    # --- Image Styling Logic ---
    # Apply specific styling for hero/banner images
    # A hero image is assumed to be a direct child of body OR inside a header element
    for img_tag in soup.find_all('img'):
        parent = img_tag.find_parent()
        if parent and (parent == body or parent.name == 'header'):
            # This is a potential hero image
            img_classes = img_tag.get('class', [])
            # Clear existing general image classes if they conflict with hero style
            img_classes = [c for c in img_classes if not c.startswith(('rounded-', 'mt-', 'mb-'))]
            img_classes.extend(['w-full', 'h-80', 'md:h-96', 'object-cover', 'mb-8']) # Added fixed height, removed rounded corners for banner effect
            img_tag['class'] = img_classes

            # Ensure the header containing the hero image also gets full width and no padding that would cut the image off
            if parent.name == 'header':
                header_classes = parent.get('class', [])
                header_classes.extend(['w-full', 'max-w-full', 'p-0', 'mb-0']) # Remove padding, ensure full width
                parent['class'] = header_classes
                
        else:
            # All other images (e.g., within content cards)
            img_classes = img_tag.get('class', [])
            # Only add if not already applied
            if not any(c.startswith('w-full') for c in img_classes):
                img_classes.extend(['w-full', 'h-auto', 'rounded-lg', 'object-cover', 'mt-4', 'mb-4'])
            img_tag['class'] = img_classes


    # Specific styling for the header (if not already handled as a section or hero container)
    header = soup.find('header')
    if header and header not in applied_sections and not (header.find('img') and header.get('class') and 'h-80' in ' '.join(header.get('class', []))): # Check if already styled as hero container
        header_classes = header.get('class', [])
        header_classes.extend(['text-center', 'mb-10', 'py-4'])
        header['class'] = header_classes
        h1 = header.find('h1')
        if h1:
            h1_classes = h1.get('class', [])
            h1_classes.extend(['text-4xl', 'md:text-5xl', 'font-extrabold', 'text-blue-700', 'mb-4'])
            h1['class'] = h1_classes
        p_header = header.find('p')
        if p_header:
            p_classes = p_header.get('class', [])
            p_classes.extend(['text-lg', 'md:text-xl', 'text-gray-600'])
            p_header['class'] = p_classes

    # Specific styling for buttons
    for button_tag in soup.find_all('button'):
        button_classes = button_tag.get('class', [])
        # Add common button styles if not already present
        if not any(c.startswith('bg-') for c in button_classes):
             button_classes.extend(['bg-blue-600', 'hover:bg-blue-700', 'text-white', 'font-bold',
                                    'py-3', 'px-6', 'rounded-lg', 'shadow-md', 'hover:shadow-lg',
                                    'transition-all', 'duration-300', 'text-lg', 'inline-flex', 'items-center', 'justify-center'])
        button_tag['class'] = button_classes

    # Specific styling for links that look like buttons
    for a_tag in soup.find_all('a'):
        # If an anchor tag contains text like "Learn More" or "View Details" and is not inside a nav
        if a_tag.get_text(strip=True).lower() in ["learn more", "view details", "read more", "get started"] and not a_tag.find_parent('nav'):
            a_classes = a_tag.get('class', [])
            if not any(c.startswith('bg-') for c in a_classes):
                a_classes.extend(['bg-blue-600', 'hover:bg-blue-700', 'text-white', 'font-bold',
                                  'py-2', 'px-4', 'rounded-lg', 'shadow-md', 'hover:shadow-lg',
                                  'transition-all', 'duration-300', 'inline-block', 'mt-4'])
            a_tag['class'] = a_classes
        else: # Default link styling
            a_classes = a_tag.get('class', [])
            if not any(c.startswith('text-') for c in a_classes):
                a_classes.extend(['text-blue-600', 'hover:underline'])
            a_tag['class'] = a_classes


    # Specific styling for the footer
    footer = soup.find('footer')
    if footer:
        footer_classes = footer.get('class', [])
        footer_classes.extend(['text-center', 'text-gray-500', 'text-sm', 'pt-8', 'border-t', 'border-gray-200', 'mt-10']) # Added margin-top
        footer['class'] = footer_classes

    # Return the modified HTML as a string
    return str(soup)

#--------------------END: Post process html--------------------------------

#     return html_clean.strip(), css, js
def clean_llm_output(code):
    # Remove markdown code block wrappers (e.g. ```html)
    return re.sub(r"```(?:html|css|javascript)?\n?|```", "", code).strip()


def extract_parts(code):
    code = clean_llm_output(code)
    css = re.search(r"<style.*?>(.*?)</style>", code, re.DOTALL)
    js = re.search(r"<script.*?>(.*?)</script>", code, re.DOTALL)
    html_clean = re.sub(r"<style.*?>.*?</style>", "", code, flags=re.DOTALL)
    html_clean = re.sub(r"<script.*?>.*?</script>", "", html_clean, flags=re.DOTALL)
    html_clean = html_clean.replace("</head>", '<link rel="stylesheet" href="style.css">\n</head>')
    html_clean = html_clean.replace("</body>", '<script src="script.js"></script>\n</body>')
    return html_clean.strip(), css.group(1).strip() if css else "", js.group(1).strip() if js else ""
def extract_parts(code):
    # This is your existing logic — unchanged
    from html.parser import HTMLParser
    import re

    html_match = re.search(r'<html[\s\S]*?</html>', code)
    css_match = re.search(r'<style.*?>([\s\S]*?)</style>', code)
    js_match = re.search(r'<script.*?>([\s\S]*?)</script>', code)

    html = html_match.group(0) if html_match else code
    css = css_match.group(1) if css_match else ""
    js = js_match.group(1) if js_match else ""
    return html, css, js
# List of fallback image URLs or relative paths
FALLBACK_IMAGES = [
    "/static/output-site/assets/image_0.jpg",
    "/static/output-site/assets/image_1.jpg",
    "/static/output-site/assets/image_2.jpg",
    "/static/output-site/assets/image_3.jpg",
    "/static/output-site/assets/image_4.jpg"
]
import random
def get_unsplash_image(query):
    
    UNSPLASH_ACCESS_KEY = os.getenv("UNSPLASH_ACCESS_KEY") or st.secrets.get("UNSPLASH_ACCESS_KEY")
    # headers = {"Authorization": f"Client-ID {UNSPLASH_ACCESS_KEY}"}
    # params = {"query": query or "website", "orientation": "landscape"}
    # r = requests.get("https://api.unsplash.com/photos/random", headers=headers, params=params)
    # r.raise_for_status()
    # return r.json()["urls"]["regular"
    headers = {"Authorization": f"Client-ID {UNSPLASH_ACCESS_KEY}"}
    params = {"query": query or "website", "orientation": "landscape"}
    
    try:
        r = requests.get("https://api.unsplash.com/photos/random", headers=headers, params=params)
        r.raise_for_status()
        return r.json()["urls"]["regular"]
    
    except requests.exceptions.RequestException as e:
        # print(f"Could not fetch image for '{query}': {e}")
        # fallback = random.choice(FALLBACK_IMAGES)
        # print(f"Using fallback image: {fallback}")
        # return fallback
        return None


def download_image(url, save_path):
    response = requests.get(url)
    with open(save_path, "wb") as f:
        f.write(response.content)


def fix_images_in_html(folder):
    html_path = os.path.join(folder, 'index.html')
    asset_folder = os.path.join(folder, 'assets')
    os.makedirs(asset_folder, exist_ok=True)

    with open(html_path, "r", encoding="utf-8") as f:
        soup = BeautifulSoup(f, "html.parser")

    for i, img in enumerate(soup.find_all("img")):
        src = img.get("src", "")
        alt = img.get("alt", f"image-{i}")
        local_path = os.path.join(folder, src)
        if "placeholder" in src or not os.path.exists(local_path):
            try:
                # print(f"🔄 Fetching Unsplash image for '{alt}'...")
                # image_url = get_unsplash_image(alt)
                # filename = f"image_{i}.jpg"
                # save_path = os.path.join(asset_folder, filename)
                # download_image(image_url, save_path)
                # img["src"] = f"assets/{filename}"
                image_url = get_unsplash_image(alt)
                filename = f"image_{i}.jpg"
                save_path = os.path.join(asset_folder, filename)

                if image_url:
                    download_image(image_url, save_path)
                    print(f"✅ Downloaded image from Unsplash for '{alt}'")
                else:
                    base_folder = r"D:\python\2025\25_06_08_llm-site-generator\static\output-site"
                    fallback_relative = FALLBACK_IMAGES[i % len(FALLBACK_IMAGES)].lstrip("/").replace("/", os.sep)
                    fallback_path = os.path.join(base_folder, fallback_relative)
                    #fallback_path = FALLBACK_IMAGES[i % len(FALLBACK_IMAGES)]
                    if os.path.exists(os.path.join(folder, fallback_path.lstrip("/"))):
                        from shutil import copyfile
                        copyfile(os.path.join(folder, fallback_path.lstrip("/")), save_path)
                        print(f"✅ Used fallback image: {fallback_path}")
                    else:
                        print(f"❌ Fallback image missing: {fallback_path}")
                        continue  # Skip this image

                img["src"] = f"assets/{filename}"

            except Exception as e:
                print(f"⚠️ Could not fetch image for '{alt}': {e}")
    

    with open(html_path, "w", encoding="utf-8") as f:
        f.write(str(soup))
    #call post process
    try:
        with open(html_path, "r", encoding="utf-8") as f:
            ollama_generated_html = f.read()
    except FileNotFoundError:
        return "<p>❌ HTML file not found.</p>"
    # Post-process the HTML
    styled_html = post_process_html(ollama_generated_html)

    #Ysave it to a file:
    with open(html_path, "w", encoding="utf-8") as f:
        f.write(styled_html)

# # working in local
# def save_code(code, folder='static/output-site'):
#     os.makedirs(folder, exist_ok=True)
#     html, css, js = extract_parts(code)

#     # Save HTML, CSS, JS
#     with open(os.path.join(folder, 'index.html'), 'w', encoding='utf-8') as f:
#         f.write(html)
#     with open(os.path.join(folder, 'style.css'), 'w', encoding='utf-8') as f:
#         f.write(css)
#     with open(os.path.join(folder, 'script.js'), 'w', encoding='utf-8') as f:
#         f.write(js)

#     # Prepare assets folder
#     asset_folder = os.path.join(folder, 'assets')
#     os.makedirs(asset_folder, exist_ok=True)

#     # Save local gallery.json with image files
#     gallery_data = []
#     for i in range(6):
#         filename = f"gallery_{i+1}.jpg"
#         save_path = os.path.join(asset_folder, filename)
        
#         try:
#             url = get_unsplash_image("portfolio photography")
#             if url:
#                 download_image(url, save_path)
#                 print(f"Downloaded Unsplash image: {filename}")
#             else:
#                 raise Exception("No image URL received from Unsplash")

#         except Exception as e:
#             print(f"Could not fetch image {i+1}: {e}")
#             fallback_path = os.path.join("static/output-site/assets", f"image_{i % len(FALLBACK_IMAGES)}.jpg")
#             if os.path.exists(fallback_path):
#                 from shutil import copyfile
#                 copyfile(fallback_path, save_path)
#                 print(f"Used fallback image: {fallback_path}")
#             else:
#                 print(f"Fallback image missing: {fallback_path}")
#                 continue  # Skip if fallback also fails

#         # Always add to gallery.json
#         gallery_data.append({"url": f"assets/{filename}"})
#     # Save gallery.json
#     with open(os.path.join(folder, 'gallery.json'), 'w', encoding='utf-8') as f:
#         json.dump(gallery_data, f, indent=2)

#     # Fix any <img src="placeholder"> in HTML
#     fix_images_in_html(folder)

# ---------------------------------this for streamlit deploy---------------------------


import os
import json
import base64
import re
from shutil import copyfile

def embed_images_as_base64(html_path, asset_folder):
    with open(html_path, "r", encoding="utf-8") as f:
        html = f.read()

    def replacer(match):
        rel_path = match.group(1)
        full_path = os.path.join(asset_folder, os.path.basename(rel_path))
        if os.path.exists(full_path):
            with open(full_path, "rb") as img_file:
                ext = os.path.splitext(full_path)[-1].replace('.', '').lower()
                encoded = base64.b64encode(img_file.read()).decode("utf-8")
                return f'src="data:image/{ext};base64,{encoded}"'
        else:
            return match.group(0)  # leave original

    # Replace all src="assets/..." with base64
    updated_html = re.sub(r'src="assets/([^"]+)"', replacer, html)

    with open(html_path, "w", encoding="utf-8") as f:
        f.write(updated_html)

def save_code(code, folder='static/output-site'):
    os.makedirs(folder, exist_ok=True)
    html, css, js = extract_parts(code)

    # Save HTML, CSS, JS
    html_path = os.path.join(folder, 'index.html')
    with open(html_path, 'w', encoding='utf-8') as f:
        f.write(html)
    with open(os.path.join(folder, 'style.css'), 'w', encoding='utf-8') as f:
        f.write(css)
    with open(os.path.join(folder, 'script.js'), 'w', encoding='utf-8') as f:
        f.write(js)

    # Prepare assets folder
    asset_folder = os.path.join(folder, 'assets')
    os.makedirs(asset_folder, exist_ok=True)

    # Save local gallery.json with image files
    gallery_data = []
    for i in range(6):
        filename = f"gallery_{i+1}.jpg"
        save_path = os.path.join(asset_folder, filename)

        try:
            url = get_unsplash_image("portfolio photography")
            if url:
                download_image(url, save_path)
                print(f"Downloaded Unsplash image: {filename}")
            else:
                raise Exception("No image URL received from Unsplash")
        except Exception as e:
            print(f"Could not fetch image {i+1}: {e}")
            fallback_path = os.path.join("static/output-site/assets", f"image_{i % len(FALLBACK_IMAGES)}.jpg")
            if os.path.exists(fallback_path):
                copyfile(fallback_path, save_path)
                print(f"Used fallback image: {fallback_path}")
            else:
                print(f"Fallback image missing: {fallback_path}")
                continue  # Skip if fallback also fails

        gallery_data.append({"url": f"assets/{filename}"})

    with open(os.path.join(folder, 'gallery.json'), 'w', encoding='utf-8') as f:
        json.dump(gallery_data, f, indent=2)

    # Fix HTML <img src="..."> placeholders
    fix_images_in_html(folder)

    # Embed assets in HTML as base64 for Streamlit preview
    embed_images_as_base64(html_path, asset_folder)



if __name__ == "__main__":
    prompt = input("Enter your website prompt: ")
    print("[⏳] Generating code from OLLAMA...")
    result = call_ollama(prompt)
    save_code(result)
